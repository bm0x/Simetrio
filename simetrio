#!/usr/bin/env python3
"""
Simetrio â€” All-in-one CLI to orchestrate builds, noVNC and cleanup.
Wraps existing scripts in this repo: multipass-run.sh, build-image.sh, novnc-run.sh, clean-build.sh, stop-novnc.sh

Usage examples:
  ./scripts/simetrio build --name stralyx --mem 4G --cpus 2 --disk 20G --with-kde --with-calamares
  ./scripts/simetrio novnc build/Stralyx/output/debian-smoke.img
  ./scripts/simetrio clean --instance-name stralyx --yes
  ./scripts/simetrio stop

This script intentionally delegates to the existing bash scripts to avoid reimplementing
complex, proven logic. It adds argument parsing, preflight checks, dry-run mode and
streamed subprocess output for a more professional UX.
"""

import argparse
import os
import shutil
import subprocess
import sys
import os
import importlib
from pathlib import Path
from types import SimpleNamespace

def find_repo_root():
    p = Path(__file__).resolve()
    cur = p.parent
    # walk upwards until we find README.md or reach filesystem root
    while cur != cur.parent:
        if (cur / 'README.md').exists():
            return cur
        cur = cur.parent
    return p.parent


REPO_ROOT = find_repo_root()
# Prefer 'bin' for executable scripts (new layout). Fall back to 'scripts' for
# older layout compatibility.
if (REPO_ROOT / 'bin').exists():
    SCRIPTS_DIR = REPO_ROOT / 'bin'
else:
    SCRIPTS_DIR = REPO_ROOT / 'scripts'

# Helper functions

def which_bin(name):
    return shutil.which(name)


def run_cmd(cmd, cwd=None, env=None, stream=True, dry=False):
    print('> ' + ' '.join(cmd))
    if dry:
        return 0
    try:
        if stream:
            p = subprocess.Popen(cmd, cwd=cwd, env=env)
            return p.wait()
        else:
            r = subprocess.run(cmd, cwd=cwd, env=env, check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            print(r.stdout)
            if r.stderr:
                print(r.stderr, file=sys.stderr)
            return r.returncode
    except FileNotFoundError:
        print(f"Command not found: {cmd[0]}", file=sys.stderr)
        return 127


def check_python_requirements(req_path=None):
    """Check Python packages listed in a requirements file are importable.
    Returns list of missing package names."""
    if req_path is None:
        # prefer scripts/requirements-simetrio.txt then repo root
        r1 = REPO_ROOT / 'scripts' / 'requirements-simetrio.txt'
        r2 = REPO_ROOT / 'requirements-simetrio.txt'
        reqf = r1 if r1.exists() else (r2 if r2.exists() else None)
    else:
        reqf = Path(req_path)
    missing = []
    if not reqf or not reqf.exists():
        return missing
    with open(reqf, 'r') as rf:
        for line in rf:
            pkg = line.strip()
            if not pkg or pkg.startswith('#'):
                continue
            # take package name before extras/version
            name = pkg.split('==')[0].split('>=')[0].split('[')[0].strip()
            # try to import common module name
            modname = name.replace('-', '_')
            try:
                importlib.import_module(modname)
            except Exception:
                missing.append(name)
    return missing


def install_python_requirements(req_path=None):
    if req_path is None:
        r1 = REPO_ROOT / 'scripts' / 'requirements-simetrio.txt'
        r2 = REPO_ROOT / 'requirements-simetrio.txt'
        reqf = r1 if r1.exists() else (r2 if r2.exists() else None)
    else:
        reqf = Path(req_path)
    if not reqf or not reqf.exists():
        print('No requirements file found to install.')
        return 1
    cmd = [sys.executable, '-m', 'pip', 'install', '-r', str(reqf)]
    return run_cmd(cmd, cwd=REPO_ROOT, stream=True)


def install_python_requirements_elevated(req_path=None):
    """Attempt to install requirements with elevated privileges on POSIX using sudo.
    On Windows this will return an error and instruct the user to run an elevated shell.
    """
    if req_path is None:
        r1 = REPO_ROOT / 'scripts' / 'requirements-simetrio.txt'
        r2 = REPO_ROOT / 'requirements-simetrio.txt'
        reqf = r1 if r1.exists() else (r2 if r2.exists() else None)
    else:
        reqf = Path(req_path)
    if not reqf or not reqf.exists():
        print('No requirements file found to install.')
        return 1
    if os.name == 'nt':
        print('Elevated installation on Windows is not automated. Please open an Administrator PowerShell and run:')
        print(f"{sys.executable} -m pip install -r {reqf}")
        return 2
    # POSIX: prefix with sudo
    cmd = ['sudo', sys.executable, '-m', 'pip', 'install', '-r', str(reqf)]
    return run_cmd(cmd, cwd=REPO_ROOT, stream=True)


def check_scripts_syntax():
    # Run bash -n on key scripts
    scripts = ['multipass-run.sh','build-rootfs-debian.sh','novnc-run.sh','clean-build.sh','build-image.sh']
    ok = True
    for s in scripts:
        path = SCRIPTS_DIR / s
        if not path.exists():
            print(f"Warning: script not found: {path}")
            ok = False
            continue
        rc = subprocess.run(['bash','-n', str(path)])
        if rc.returncode != 0:
            print(f"Syntax error in {path}")
            ok = False
    return ok


def preflight_checks():
    missing = []
    for binname in ('multipass','qemu-system-x86_64','python3'):
        if which_bin(binname) is None:
            missing.append(binname)
    if missing:
        print('Missing required binaries: ' + ', '.join(missing))
        print('You may still be able to run non-multipass flows, but multipass builds will fail.')
        return False
    return True


# Subcommands

def cmd_build(args):
    # prefer multipass-run.sh
    multipass = SCRIPTS_DIR / 'multipass-run.sh'
    if not multipass.exists():
        print('multipass-run.sh not found; cannot perform multipass build.', file=sys.stderr)
        return 1

    cmd = [str(multipass)]
    # map args
    if args.name:
        cmd += ['--name', args.name]
    if args.mem:
        cmd += ['--mem', args.mem]
    if args.cpus:
        cmd += ['--cpus', str(args.cpus)]
    if args.disk:
        cmd += ['--disk', args.disk]
    if args.with_kde:
        cmd += ['--with-kde']
    if args.with_calamares:
        cmd += ['--with-calamares']

    # Ensure scripts are executable
    for s in ('multipass-run.sh','build-rootfs-debian.sh'):
        p = SCRIPTS_DIR / s
        if p.exists():
            p.chmod(p.stat().st_mode | 0o111)

    # syntax check
    ok = check_scripts_syntax()
    if not ok:
        print('Syntax problems detected in scripts; aborting.')
        return 2

    # Run
    return run_cmd(cmd, cwd=REPO_ROOT, stream=True, dry=args.dry)


def cmd_novnc(args):
    novnc = SCRIPTS_DIR / 'novnc-run.sh'
    if not novnc.exists():
        print('novnc-run.sh not found.', file=sys.stderr)
        return 1
    cmd = [str(novnc), args.image]
    # make executable
    novnc.chmod(novnc.stat().st_mode | 0o111)
    return run_cmd(cmd, cwd=REPO_ROOT, stream=True, dry=args.dry)


def cmd_clean(args):
    clean = SCRIPTS_DIR / 'clean-build.sh'
    if not clean.exists():
        print('clean-build.sh not found.', file=sys.stderr)
        return 1
    cmd = [str(clean)]
    if args.yes:
        cmd += ['--yes']
    if args.remove_instance:
        cmd += ['--remove-instance']
    if args.instance_name:
        cmd += ['--instance-name', args.instance_name]
    clean.chmod(clean.stat().st_mode | 0o111)
    return run_cmd(cmd, cwd=REPO_ROOT, stream=True, dry=args.dry)


def cmd_stop(args):
    stop = SCRIPTS_DIR / 'stop-novnc.sh'
    if not stop.exists():
        print('stop-novnc.sh not found.', file=sys.stderr)
        return 1
    stop.chmod(stop.stat().st_mode | 0o111)
    return run_cmd([str(stop)], cwd=REPO_ROOT, stream=True, dry=args.dry)


def cmd_check(args):
    ok1 = check_scripts_syntax()
    ok2 = preflight_checks()
    if ok1 and ok2:
        print('Preflight checks passed.')
        return 0
    return 1


def cmd_deps(args):
    """Run dependency checks and optionally install Python requirements."""
    missing_bins = [b for b in ('multipass','qemu-system-x86_64','python3') if which_bin(b) is None]
    if missing_bins:
        print('Missing binaries: ' + ', '.join(missing_bins))
    else:
        print('All required binaries present.')

    missing_pkgs = check_python_requirements()
    if missing_pkgs:
        print('Missing Python packages: ' + ', '.join(missing_pkgs))
        if args.install_python:
            print('Installing Python requirements...')
            if getattr(args, 'elevate', False):
                rc = install_python_requirements_elevated()
            else:
                rc = install_python_requirements()
            return rc
        return 2
    else:
        print('Python requirements satisfied.')
    return 0


def main(argv=None):
    # If invoked without args, start interactive TUI
    if argv is None:
        argv = sys.argv[1:]

    if len(argv) == 0:
        # Prefer the full-screen Textual TUI if available
        # locate the TUI script: prefer scripts/ but fall back to repo root
        tui_script = SCRIPTS_DIR / 'simetrio_tui.py'
        if not tui_script.exists():
            alt = REPO_ROOT / 'simetrio_tui.py'
            if alt.exists():
                tui_script = alt
        try:
            import textual  # type: ignore
            have_textual = True
        except Exception:
            have_textual = False

        if not have_textual and tui_script.exists():
            # Offer to install requirements and report clearly; then attempt to import
            if sys.stdin.isatty():
                ans = input('Textual not found. Install UI deps now? (requires pip) [y/N]: ').strip().lower()
                if ans == 'y':
                    # Find requirements file either in scripts/ or repo root
                    r1 = SCRIPTS_DIR / 'requirements-simetrio.txt'
                    r2 = REPO_ROOT / 'requirements-simetrio.txt'
                    reqs = r1 if r1.exists() else (r2 if r2.exists() else None)
                    if reqs:
                        print('Installing UI dependencies (this may require network access and privileges)...')
                        rc = run_cmd([sys.executable, '-m', 'pip', 'install', '-r', str(reqs)], cwd=REPO_ROOT, stream=True)
                        if rc != 0:
                            print('Failed to install UI dependencies (pip returned non-zero). Aborting TUI launch.')
                            return 1
                        # try import again; if import fails, warn but attempt to
                        # execv the TUI anyway â€” a fresh interpreter is more
                        # likely to pick up newly installed site-packages.
                        try:
                            import textual  # type: ignore
                            have_textual = True
                        except Exception as e:
                            print('Warning: Textual import failed after installation:', e)
                            have_textual = False
                        # If we're interactive, relaunch the TUI in-place so the
                        # user is immediately dropped into the Textual interface.
                        if sys.stdin.isatty():
                            try:
                                print('Launching TUI...')
                                os.execv(sys.executable, [sys.executable, str(tui_script)])
                            except Exception as e:
                                print('Failed to execv relaunched TUI:', e)
                                return 1
                    else:
                        print('Requirements file not found in scripts/ or repo root. Cannot install UI deps.')
                        return 1
                else:
                    print('Textual not installed; skipping TUI. Exiting.')
                    return 1
            else:
                print('Textual not available and non-interactive shell; cannot launch TUI. Exiting.')
                return 1

        if have_textual and tui_script.exists():
            # Prefer interactive launch: if the user is at a terminal, run the TUI
            # attached to the terminal so it displays; only capture to a log when
            # running non-interactively (CI or piping).
            logdir = REPO_ROOT / 'build' / 'logs'
            logdir.mkdir(parents=True, exist_ok=True)
            logpath = logdir / 'simetrio-tui.log'

            if sys.stdin.isatty():
                # Interactive terminal: run TUI attached so user can interact with it.
                try:
                    rc = subprocess.call([sys.executable, str(tui_script)])
                except KeyboardInterrupt:
                    rc = 130
            else:
                # Non-interactive: capture stdout/stderr to a log for debugging
                with open(logpath, 'wb') as lf:
                    p = subprocess.Popen([sys.executable, str(tui_script)], stdout=lf, stderr=subprocess.STDOUT)
                    try:
                        rc = p.wait()
                    except KeyboardInterrupt:
                        p.terminate()
                        rc = p.wait()

            if rc != 0:
                print(f"Simetrio TUI exited with {rc}. Captured log: {logpath}")
                # print last 200 lines to make copying easier
                try:
                    with open(logpath, 'r', errors='replace') as rf:
                        lines = rf.readlines()
                        tail = lines[-200:]
                        print('\n=== Last log lines ===')
                        print(''.join(tail))
                except Exception as e:
                    print('Failed to read log:', e)
                return rc

            # If TUI script not available or textual not installed we exit instead of falling back to the legacy interactive menu
            print('TUI not available; exiting.')
            return 1

    parser = argparse.ArgumentParser(prog='simetrio', description='Simetrio â€” AIO build & test CLI for this repo')
    parser.add_argument('--dry', dest='dry', action='store_true', help='Print commands but do not execute')

    sub = parser.add_subparsers(dest='cmd', required=True)

    p_build = sub.add_parser('build', help='Build image (wraps multipass-run.sh)')
    p_build.add_argument('--name', default='stralyx')
    p_build.add_argument('--mem', default='4G')
    p_build.add_argument('--cpus', type=int, default=2)
    p_build.add_argument('--disk', default='20G')
    p_build.add_argument('--with-kde', dest='with_kde', action='store_true')
    p_build.add_argument('--with-calamares', dest='with_calamares', action='store_true')

    p_novnc = sub.add_parser('novnc', help='Run noVNC against an image')
    p_novnc.add_argument('image', help='Path to .img')

    p_clean = sub.add_parser('clean', help='Clean build artifacts and optionally remove multipass instance')
    p_clean.add_argument('--yes', action='store_true', help='Confirm removal')
    p_clean.add_argument('--remove-instance', action='store_true')
    p_clean.add_argument('--instance-name', default='stralyx')

    sub.add_parser('stop', help='Stop running noVNC (qemu + websockify)')
    sub.add_parser('check', help='Run preflight checks (binaries + script syntax)')
    p_deps = sub.add_parser('deps', help='Check dependencies and optionally install Python requirements')
    p_deps.add_argument('--install-python', action='store_true', help='Install python requirements from requirements-simetrio.txt')
    p_deps.add_argument('--elevate', action='store_true', help='Attempt to run pip install with elevated privileges (uses sudo on POSIX)')

    args = parser.parse_args(argv)

    if args.cmd == 'build':
        return cmd_build(args)
    if args.cmd == 'novnc':
        return cmd_novnc(args)
    if args.cmd == 'clean':
        return cmd_clean(args)
    if args.cmd == 'stop':
        return cmd_stop(args)
    if args.cmd == 'check':
        return cmd_check(args)
    if args.cmd == 'deps':
        return cmd_deps(args)

    return 0


if __name__ == '__main__':
    rc = main()
    sys.exit(rc)
