#!/usr/bin/env python3
"""
Simetrio — All-in-one CLI to orchestrate builds, noVNC and cleanup.
Wraps existing scripts in this repo: multipass-run.sh, build-image.sh, novnc-run.sh, clean-build.sh, stop-novnc.sh

Usage examples:
  ./scripts/simetrio build --name stralyx --mem 4G --cpus 2 --disk 20G --with-kde --with-calamares
  ./scripts/simetrio novnc build/Stralyx/output/debian-smoke.img
  ./scripts/simetrio clean --instance-name stralyx --yes
  ./scripts/simetrio stop

This script intentionally delegates to the existing bash scripts to avoid reimplementing
complex, proven logic. It adds argument parsing, preflight checks, dry-run mode and
streamed subprocess output for a more professional UX.
"""

import argparse
import os
import shutil
import subprocess
import sys
from pathlib import Path
from types import SimpleNamespace

REPO_ROOT = Path(__file__).resolve().parent.parent
SCRIPTS_DIR = REPO_ROOT / 'scripts'

# Helper functions

def which_bin(name):
    return shutil.which(name)


def run_cmd(cmd, cwd=None, env=None, stream=True, dry=False):
    print('> ' + ' '.join(cmd))
    if dry:
        return 0
    try:
        if stream:
            p = subprocess.Popen(cmd, cwd=cwd, env=env)
            return p.wait()
        else:
            r = subprocess.run(cmd, cwd=cwd, env=env, check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            print(r.stdout)
            if r.stderr:
                print(r.stderr, file=sys.stderr)
            return r.returncode
    except FileNotFoundError:
        print(f"Command not found: {cmd[0]}", file=sys.stderr)
        return 127


def check_scripts_syntax():
    # Run bash -n on key scripts
    scripts = ['multipass-run.sh','build-rootfs-debian.sh','novnc-run.sh','clean-build.sh','build-image.sh']
    ok = True
    for s in scripts:
        path = SCRIPTS_DIR / s
        if not path.exists():
            print(f"Warning: script not found: {path}")
            ok = False
            continue
        rc = subprocess.run(['bash','-n', str(path)])
        if rc.returncode != 0:
            print(f"Syntax error in {path}")
            ok = False
    return ok


def preflight_checks():
    missing = []
    for binname in ('multipass','qemu-system-x86_64','python3'):
        if which_bin(binname) is None:
            missing.append(binname)
    if missing:
        print('Missing required binaries: ' + ', '.join(missing))
        print('You may still be able to run non-multipass flows, but multipass builds will fail.')
        return False
    return True


# Subcommands

def cmd_build(args):
    # prefer multipass-run.sh
    multipass = SCRIPTS_DIR / 'multipass-run.sh'
    if not multipass.exists():
        print('multipass-run.sh not found; cannot perform multipass build.', file=sys.stderr)
        return 1

    cmd = [str(multipass)]
    # map args
    if args.name:
        cmd += ['--name', args.name]
    if args.mem:
        cmd += ['--mem', args.mem]
    if args.cpus:
        cmd += ['--cpus', str(args.cpus)]
    if args.disk:
        cmd += ['--disk', args.disk]
    if args.with_kde:
        cmd += ['--with-kde']
    if args.with_calamares:
        cmd += ['--with-calamares']

    # Ensure scripts are executable
    for s in ('multipass-run.sh','build-rootfs-debian.sh'):
        p = SCRIPTS_DIR / s
        if p.exists():
            p.chmod(p.stat().st_mode | 0o111)

    # syntax check
    ok = check_scripts_syntax()
    if not ok:
        print('Syntax problems detected in scripts; aborting.')
        return 2

    # Run
    return run_cmd(cmd, cwd=REPO_ROOT, stream=True, dry=args.dry)


def cmd_novnc(args):
    novnc = SCRIPTS_DIR / 'novnc-run.sh'
    if not novnc.exists():
        print('novnc-run.sh not found.', file=sys.stderr)
        return 1
    cmd = [str(novnc), args.image]
    # make executable
    novnc.chmod(novnc.stat().st_mode | 0o111)
    return run_cmd(cmd, cwd=REPO_ROOT, stream=True, dry=args.dry)


def cmd_clean(args):
    clean = SCRIPTS_DIR / 'clean-build.sh'
    if not clean.exists():
        print('clean-build.sh not found.', file=sys.stderr)
        return 1
    cmd = [str(clean)]
    if args.yes:
        cmd += ['--yes']
    if args.remove_instance:
        cmd += ['--remove-instance']
    if args.instance_name:
        cmd += ['--instance-name', args.instance_name]
    clean.chmod(clean.stat().st_mode | 0o111)
    return run_cmd(cmd, cwd=REPO_ROOT, stream=True, dry=args.dry)


def cmd_stop(args):
    stop = SCRIPTS_DIR / 'stop-novnc.sh'
    if not stop.exists():
        print('stop-novnc.sh not found.', file=sys.stderr)
        return 1
    stop.chmod(stop.stat().st_mode | 0o111)
    return run_cmd([str(stop)], cwd=REPO_ROOT, stream=True, dry=args.dry)


def cmd_check(args):
    ok1 = check_scripts_syntax()
    ok2 = preflight_checks()
    if ok1 and ok2:
        print('Preflight checks passed.')
        return 0
    return 1


def main(argv=None):
    # If invoked without args, start interactive TUI
    if argv is None:
        argv = sys.argv[1:]

    if len(argv) == 0:
        # Prefer the full-screen Textual TUI if available
        tui_script = SCRIPTS_DIR / 'simetrio_tui.py'
        try:
            import textual  # type: ignore
            have_textual = True
        except Exception:
            have_textual = False

        if not have_textual and tui_script.exists():
            # Offer to install requirements
            if sys.stdin.isatty():
                ans = input('Textual not found. Install UI deps now? (requires pip) [y/N]: ').strip().lower()
                if ans == 'y':
                    reqs = SCRIPTS_DIR / 'requirements-simetrio.txt'
                    if reqs.exists():
                        rc = subprocess.call([sys.executable, '-m', 'pip', 'install', '-r', str(reqs)])
                        if rc == 0:
                            try:
                                import textual  # type: ignore
                                have_textual = True
                            except Exception:
                                have_textual = False
            else:
                # non-interactive, don't auto-install
                have_textual = False

        if have_textual and tui_script.exists():
            # Prefer interactive launch: if the user is at a terminal, run the TUI
            # attached to the terminal so it displays; only capture to a log when
            # running non-interactively (CI or piping).
            logdir = REPO_ROOT / 'build' / 'logs'
            logdir.mkdir(parents=True, exist_ok=True)
            logpath = logdir / 'simetrio-tui.log'

            if sys.stdin.isatty():
                # Interactive terminal: run TUI attached so user can interact with it.
                try:
                    rc = subprocess.call([sys.executable, str(tui_script)])
                except KeyboardInterrupt:
                    rc = 130
            else:
                # Non-interactive: capture stdout/stderr to a log for debugging
                with open(logpath, 'wb') as lf:
                    p = subprocess.Popen([sys.executable, str(tui_script)], stdout=lf, stderr=subprocess.STDOUT)
                    try:
                        rc = p.wait()
                    except KeyboardInterrupt:
                        p.terminate()
                        rc = p.wait()

            if rc != 0:
                print(f"Simetrio TUI exited with {rc}. Captured log: {logpath}")
                # print last 200 lines to make copying easier
                try:
                    with open(logpath, 'r', errors='replace') as rf:
                        lines = rf.readlines()
                        tail = lines[-200:]
                        print('\n=== Last log lines ===')
                        print(''.join(tail))
                except Exception as e:
                    print('Failed to read log:', e)
            return rc

        return interactive_menu()

    parser = argparse.ArgumentParser(prog='simetrio', description='Simetrio — AIO build & test CLI for this repo')
    parser.add_argument('--dry', dest='dry', action='store_true', help='Print commands but do not execute')

    sub = parser.add_subparsers(dest='cmd', required=True)

    p_build = sub.add_parser('build', help='Build image (wraps multipass-run.sh)')
    p_build.add_argument('--name', default='stralyx')
    p_build.add_argument('--mem', default='4G')
    p_build.add_argument('--cpus', type=int, default=2)
    p_build.add_argument('--disk', default='20G')
    p_build.add_argument('--with-kde', dest='with_kde', action='store_true')
    p_build.add_argument('--with-calamares', dest='with_calamares', action='store_true')

    p_novnc = sub.add_parser('novnc', help='Run noVNC against an image')
    p_novnc.add_argument('image', help='Path to .img')

    p_clean = sub.add_parser('clean', help='Clean build artifacts and optionally remove multipass instance')
    p_clean.add_argument('--yes', action='store_true', help='Confirm removal')
    p_clean.add_argument('--remove-instance', action='store_true')
    p_clean.add_argument('--instance-name', default='stralyx')

    sub.add_parser('stop', help='Stop running noVNC (qemu + websockify)')
    sub.add_parser('check', help='Run preflight checks (binaries + script syntax)')

    args = parser.parse_args(argv)

    if args.cmd == 'build':
        return cmd_build(args)
    if args.cmd == 'novnc':
        return cmd_novnc(args)
    if args.cmd == 'clean':
        return cmd_clean(args)
    if args.cmd == 'stop':
        return cmd_stop(args)
    if args.cmd == 'check':
        return cmd_check(args)

    return 0


def interactive_menu():
    """Simple terminal UI: ask the user what to run and collect parameters interactively."""
    try:
        while True:
            print('\nSimetrio — Interactive menu')
            print('1) Build image (multipass)')
            print('2) Run noVNC against image')
            print('3) Clean build artifacts / remove instance')
            print('4) Stop noVNC (qemu + websockify)')
            print('5) Preflight checks')
            print('6) Exit')
            choice = input('Choose an option [1-6]: ').strip()
            if choice == '1':
                name = input('Instance name [stralyx]: ').strip() or 'stralyx'
                mem = input('Memory [4G]: ').strip() or '4G'
                cpus = input('CPUs [2]: ').strip() or '2'
                disk = input('Disk [20G]: ').strip() or '20G'
                with_kde = input('Install KDE? (y/N): ').strip().lower() == 'y'
                with_calamares = input('Install Calamares? (y/N): ').strip().lower() == 'y'
                dry = input('Dry run? (y/N): ').strip().lower() == 'y'
                ns = SimpleNamespace(name=name, mem=mem, cpus=int(cpus), disk=disk, with_kde=with_kde, with_calamares=with_calamares, dry=dry)
                rc = cmd_build(ns)
                print('Return code:', rc)
            elif choice == '2':
                default_img = str(REPO_ROOT / 'build' / REPO_ROOT.name / 'output' / f'{REPO_ROOT.name}-smoke.img')
                img = input(f'Image path [{default_img}]: ').strip() or default_img
                dry = input('Dry run? (y/N): ').strip().lower() == 'y'
                ns = SimpleNamespace(image=img, dry=dry)
                rc = cmd_novnc(ns)
                print('Return code:', rc)
            elif choice == '3':
                yes = input('Confirm delete build artifacts? (y/N): ').strip().lower() == 'y'
                remove = input('Remove multipass instance? (y/N): ').strip().lower() == 'y'
                instance = input('Instance name [stralyx]: ').strip() or 'stralyx'
                ns = SimpleNamespace(yes=yes, remove_instance=remove, instance_name=instance, dry=False)
                rc = cmd_clean(ns)
                print('Return code:', rc)
            elif choice == '4':
                rc = cmd_stop(SimpleNamespace())
                print('Return code:', rc)
            elif choice == '5':
                rc = cmd_check(SimpleNamespace())
                print('Return code:', rc)
            elif choice == '6' or choice.lower() in ('q','quit','exit'):
                print('Exiting Simetrio.')
                return 0
            else:
                print('Invalid choice, try again.')
    except (EOFError, KeyboardInterrupt):
        print('\nExiting Simetrio.')
        return 0


if __name__ == '__main__':
    rc = main()
    sys.exit(rc)
