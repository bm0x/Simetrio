#!/usr/bin/env python3
"""
Simetrio — All-in-one CLI to orchestrate builds, noVNC and cleanup.
Wraps existing scripts in this repo: multipass-run.sh, build-image.sh, novnc-run.sh, clean-build.sh, stop-novnc.sh

Usage examples:
  ./scripts/simetrio build --name stralyx --mem 4G --cpus 2 --disk 20G --with-kde --with-calamares
  ./scripts/simetrio novnc build/Stralyx/output/debian-smoke.img
  ./scripts/simetrio clean --instance-name stralyx --yes
  ./scripts/simetrio stop

This script intentionally delegates to the existing bash scripts to avoid reimplementing
complex, proven logic. It adds argument parsing, preflight checks, dry-run mode and
streamed subprocess output for a more professional UX.
"""

import argparse
import os
import shutil
import subprocess
import sys
import os
import importlib
from pathlib import Path
from types import SimpleNamespace
from datetime import datetime

def find_repo_root():
    p = Path(__file__).resolve()
    cur = p.parent
    # walk upwards until we find README.md or reach filesystem root
    while cur != cur.parent:
        if (cur / 'README.md').exists():
            return cur
        cur = cur.parent
    return p.parent


def get_log_dir():
    """Return a writable log directory. Prefer REPO_ROOT/build/logs, but if it's not writable
    (e.g., owned by root) fall back to the user's cache directory under $HOME/.cache/simetrio/logs.
    """
    preferred = REPO_ROOT / 'build' / 'logs'
    try:
        preferred.mkdir(parents=True, exist_ok=True)
        # test writability
        testfile = preferred / '.simetrio_write_test'
        with open(testfile, 'w') as f:
            f.write('ok')
        testfile.unlink()
        return preferred
    except Exception:
        # fallback to user cache
        fallback = Path.home() / '.cache' / 'simetrio' / 'logs'
        fallback.mkdir(parents=True, exist_ok=True)
        return fallback


REPO_ROOT = find_repo_root()
# Prefer 'bin' for executable scripts (new layout). Fall back to 'scripts' for
# older layout compatibility.
if (REPO_ROOT / 'bin').exists():
    SCRIPTS_DIR = REPO_ROOT / 'bin'
else:
    SCRIPTS_DIR = REPO_ROOT / 'scripts'

# Helper functions

def which_bin(name):
    return shutil.which(name)


def run_cmd(cmd, cwd=None, env=None, stream=True, dry=False):
    print('> ' + ' '.join(cmd))
    if dry:
        return 0
    try:
        if stream:
            p = subprocess.Popen(cmd, cwd=cwd, env=env)
            return p.wait()
        else:
            r = subprocess.run(cmd, cwd=cwd, env=env, check=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            print(r.stdout)
            if r.stderr:
                print(r.stderr, file=sys.stderr)
            return r.returncode
    except FileNotFoundError:
        print(f"Command not found: {cmd[0]}", file=sys.stderr)
        return 127


def check_python_requirements(req_path=None):
    """Check Python packages listed in a requirements file are importable.
    Returns list of missing package names."""
    if req_path is None:
        # prefer scripts/requirements-simetrio.txt then repo root
        r1 = REPO_ROOT / 'scripts' / 'requirements-simetrio.txt'
        r2 = REPO_ROOT / 'requirements-simetrio.txt'
        reqf = r1 if r1.exists() else (r2 if r2.exists() else None)
    else:
        reqf = Path(req_path)
    missing = []
    if not reqf or not reqf.exists():
        return missing
    with open(reqf, 'r') as rf:
        for line in rf:
            pkg = line.strip()
            if not pkg or pkg.startswith('#'):
                continue
            # take package name before extras/version
            name = pkg.split('==')[0].split('>=')[0].split('[')[0].strip()
            # try to import common module name
            modname = name.replace('-', '_')
            try:
                importlib.import_module(modname)
            except Exception:
                missing.append(name)
    return missing


def install_python_requirements(req_path=None):
    if req_path is None:
        r1 = REPO_ROOT / 'scripts' / 'requirements-simetrio.txt'
        r2 = REPO_ROOT / 'requirements-simetrio.txt'
        reqf = r1 if r1.exists() else (r2 if r2.exists() else None)
    else:
        reqf = Path(req_path)
    if not reqf or not reqf.exists():
        print('No requirements file found to install.')
        return 1
    # If we're not inside a virtualenv, prefer installing to user site to avoid
    # requiring root. If running inside a venv, install into the active env.
    in_venv = (hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix))
    cmd = [sys.executable, '-m', 'pip', 'install', '-r', str(reqf)]
    if not in_venv:
        # use --user to avoid system-wide installs by default
        cmd.insert(4, '--user')

    # Ensure log directory exists and capture pip output to a timestamped log
    logdir = get_log_dir()
    ts = datetime.utcnow().strftime('%Y%m%d-%H%M%SZ')
    logfile = logdir / f'pip-install-{ts}.log'
    print(f'Logging pip output to: {logfile}')

    p = subprocess.Popen(cmd, cwd=REPO_ROOT, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    with open(logfile, 'w', encoding='utf-8') as lf:
        for line in p.stdout:
            print(line, end='')
            lf.write(line)
    rc = p.wait()
    return rc


def install_python_requirements_elevated(req_path=None):
    """Attempt to install requirements with elevated privileges on POSIX using sudo.
    On Windows this will return an error and instruct the user to run an elevated shell.
    """
    if req_path is None:
        r1 = REPO_ROOT / 'scripts' / 'requirements-simetrio.txt'
        r2 = REPO_ROOT / 'requirements-simetrio.txt'
        reqf = r1 if r1.exists() else (r2 if r2.exists() else None)
    else:
        reqf = Path(req_path)
    if not reqf or not reqf.exists():
        print('No requirements file found to install.')
        return 1
    if os.name == 'nt':
        print('Elevated installation on Windows is not automated. Please open an Administrator PowerShell and run:')
        print(f"{sys.executable} -m pip install -r {reqf}")
        return 2
    # If we're inside a virtualenv, elevated install is not required and may be
    # harmful (it would attempt to modify system interpreters). In that case
    # fall back to normal install into the venv.
    in_venv = (hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix))
    if in_venv:
        print('Running inside a virtualenv — performing install into the active environment rather than using sudo.')
        return install_python_requirements(req_path=req_path)
    # POSIX: prefix with sudo for system-wide install
    cmd = ['sudo', sys.executable, '-m', 'pip', 'install', '-r', str(reqf)]

    # Ensure log directory exists and capture pip output to a timestamped log
    logdir = get_log_dir()
    ts = datetime.utcnow().strftime('%Y%m%d-%H%M%SZ')
    logfile = logdir / f'pip-install-{ts}-elevated.log'
    print(f'Logging elevated pip output to: {logfile}')

    p = subprocess.Popen(cmd, cwd=REPO_ROOT, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    with open(logfile, 'w', encoding='utf-8') as lf:
        for line in p.stdout:
            print(line, end='')
            lf.write(line)
    rc = p.wait()
    return rc


def check_scripts_syntax():
    # Run bash -n on key scripts
    scripts = ['multipass-run.sh','build-rootfs-debian.sh','novnc-run.sh','clean-build.sh','build-image.sh']
    ok = True
    for s in scripts:
        path = SCRIPTS_DIR / s
        if not path.exists():
            print(f"Warning: script not found: {path}")
            ok = False
            continue
        rc = subprocess.run(['bash','-n', str(path)])
        if rc.returncode != 0:
            print(f"Syntax error in {path}")
            ok = False
    return ok


def install_system_binaries(bins=('multipass','qemu-system-x86_64'), elevate=False):
    """Attempt to install missing system binaries for common platforms.
    This is best-effort: it will try Homebrew on macOS, snap/apt on Debian/Ubuntu,
    and Chocolatey on Windows. Returns 0 on success, non-zero otherwise.
    """
    missing = [b for b in bins if which_bin(b) is None]
    if not missing:
        print('No system binaries to install.')
        return 0

    logdir = get_log_dir()
    ts = datetime.utcnow().strftime('%Y%m%d-%H%M%SZ')
    logfile = logdir / f'system-install-{ts}.log'
    print(f'Attempting to install system binaries: {missing}. Logging to {logfile}')

    overall_rc = 0
    with open(logfile, 'w', encoding='utf-8') as lf:
        for b in missing:
            if sys.platform.startswith('darwin'):
                if b == 'multipass':
                    cmd = ['brew', 'install', '--cask', 'multipass']
                elif 'qemu' in b:
                    cmd = ['brew', 'install', 'qemu']
                else:
                    lf.write(f'No automated installer for {b} on macOS\n')
                    overall_rc = overall_rc or 2
                    continue
            elif sys.platform.startswith('linux'):
                # Prefer snap for multipass; fall back to apt for qemu
                if b == 'multipass':
                    if shutil.which('snap'):
                        cmd = ['snap', 'install', 'multipass', '--classic']
                        if elevate and os.name != 'nt':
                            cmd.insert(0, 'sudo')
                    else:
                        # attempt apt
                        cmd = ['apt', 'update']
                elif 'qemu' in b:
                    cmd = ['apt', 'install', '-y', 'qemu-system']
                    if elevate and os.name != 'nt':
                        cmd.insert(0, 'sudo')
                else:
                    lf.write(f'No automated installer for {b} on Linux\n')
                    overall_rc = overall_rc or 2
                    continue
            elif os.name == 'nt':
                # Windows: try Chocolatey
                if shutil.which('choco'):
                    if b == 'multipass':
                        cmd = ['choco', 'install', '-y', 'multipass']
                    elif 'qemu' in b:
                        cmd = ['choco', 'install', '-y', 'qemu']
                    else:
                        lf.write(f'No automated installer for {b} on Windows\n')
                        overall_rc = overall_rc or 2
                        continue
                else:
                    lf.write('Chocolatey not found; cannot auto-install on Windows\n')
                    overall_rc = overall_rc or 2
                    continue
            else:
                lf.write(f'Unsupported platform for automated install: {sys.platform}\n')
                overall_rc = overall_rc or 2
                continue

            # Run the install command and capture output
            lf.write(f'Running: {cmd}\n')
            # Safety: do not run Homebrew as root — skip and inform user
            try:
                if sys.platform.startswith('darwin') and cmd and cmd[0] == 'brew' and hasattr(os, 'geteuid') and os.geteuid() == 0:
                    # If running under sudo, prefer to run brew as the original user
                    sudo_user = os.environ.get('SUDO_USER')
                    if sudo_user:
                        # run brew as the original user to avoid Homebrew root error
                        run_as = ['sudo', '-u', sudo_user]
                        lf.write(f'Running brew as user {sudo_user} via: {run_as + cmd}\n')
                        cmd = run_as + cmd
                    else:
                        msg = ('Refusing to run Homebrew as root. Please run the following command as your regular user (without sudo):\n'
                               + '    ' + ' '.join(cmd) + '\n')
                        print(msg)
                        lf.write(msg + '\n')
                        overall_rc = overall_rc or 1
                        continue
                p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
                for line in p.stdout:
                    print(line, end='')
                    lf.write(line)
                rc = p.wait()
                if rc != 0:
                    lf.write(f'Command {cmd} exited with {rc}\n')
                    overall_rc = overall_rc or rc or 4
            except FileNotFoundError:
                lf.write(f'Installer command not found for: {cmd[0]}\n')
                overall_rc = overall_rc or 2
        # Special-case: Homebrew may download a Multipass PKG into Caskroom
        # (e.g. /usr/local/Caskroom/multipass/<version>/multipass-<ver>+mac-Darwin.pkg)
        # but not run the system installer. If multipass is still missing and
        # we find a PKG, offer to run the macOS `installer` tool when elevated.
        if sys.platform.startswith('darwin') and 'multipass' in missing and which_bin('multipass') is None:
            # Search common Homebrew Caskroom locations
            cask_paths = [Path('/usr/local/Caskroom'), Path('/opt/homebrew/Caskroom'), Path('/usr/local/Caskroom/multipass')]
            found_pkg = None
            for base in cask_paths:
                if not base.exists():
                    continue
                # look for any .pkg file under multipass folder
                for p in base.rglob('*.pkg'):
                    # heuristics: contain 'multipass' in filename or be inside multipass folder
                    if 'multipass' in p.name.lower() or 'multipass' in str(p.parent).lower():
                        found_pkg = p
                        break
                if found_pkg:
                    break

            if found_pkg:
                lf.write(f'Found Multipass PKG at {found_pkg}\n')
                print(f'Found Multipass PKG at: {found_pkg}')
                # Only attempt to run the system installer if we have elevation
                have_elevation = False
                try:
                    have_elevation = (hasattr(os, 'geteuid') and os.geteuid() == 0) or bool(elevate)
                except Exception:
                    have_elevation = bool(elevate)

                installer_cmd = ['installer', '-pkg', str(found_pkg), '-target', '/']
                if have_elevation and os.name != 'nt':
                    # If not running as root but user requested elevate, prefix with sudo
                    if not (hasattr(os, 'geteuid') and os.geteuid() == 0) and bool(elevate):
                        installer_cmd = ['sudo'] + installer_cmd
                    lf.write(f'Running system installer: {installer_cmd}\n')
                    try:
                        p2 = subprocess.Popen(installer_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
                        for line in p2.stdout:
                            print(line, end='')
                            lf.write(line)
                        rc2 = p2.wait()
                        if rc2 != 0:
                            lf.write(f'installer exited with {rc2}\n')
                            overall_rc = overall_rc or rc2 or 8
                        else:
                            lf.write('installer completed successfully\n')
                    except FileNotFoundError:
                        msg = 'macOS installer tool not found; cannot run PKG installer programmatically.'
                        print(msg)
                        lf.write(msg + '\n')
                        overall_rc = overall_rc or 2
                else:
                    msg = (f'Multipass PKG present at {found_pkg}. To complete the installation run as an administrator:\n'
                           f'    sudo installer -pkg {found_pkg} -target /\n')
                    print(msg)
                    lf.write(msg + '\n')
                    overall_rc = overall_rc or 1
    return overall_rc


def preflight_checks():
    missing = []
    for binname in ('multipass','qemu-system-x86_64','python3'):
        if which_bin(binname) is None:
            missing.append(binname)
    if missing:
        print('Missing required binaries: ' + ', '.join(missing))
        print('You may still be able to run non-multipass flows, but multipass builds will fail.')
        return False
    return True


# Subcommands

def cmd_build(args):
    # prefer multipass-run.sh
    multipass = SCRIPTS_DIR / 'multipass-run.sh'
    if not multipass.exists():
        print('multipass-run.sh not found; cannot perform multipass build.', file=sys.stderr)
        return 1

    cmd = [str(multipass)]
    # map args
    if args.name:
        cmd += ['--name', args.name]
    if args.mem:
        cmd += ['--mem', args.mem]
    if args.cpus:
        cmd += ['--cpus', str(args.cpus)]
    if args.disk:
        cmd += ['--disk', args.disk]
    if args.with_kde:
        cmd += ['--with-kde']
    if args.with_calamares:
        cmd += ['--with-calamares']

    # Ensure scripts are executable
    for s in ('multipass-run.sh','build-rootfs-debian.sh'):
        p = SCRIPTS_DIR / s
        if p.exists():
            p.chmod(p.stat().st_mode | 0o111)

    # syntax check
    ok = check_scripts_syntax()
    if not ok:
        print('Syntax problems detected in scripts; aborting.')
        return 2

    # Run
    return run_cmd(cmd, cwd=REPO_ROOT, stream=True, dry=args.dry)


def cmd_novnc(args):
    novnc = SCRIPTS_DIR / 'novnc-run.sh'
    if not novnc.exists():
        print('novnc-run.sh not found.', file=sys.stderr)
        return 1
    cmd = [str(novnc), args.image]
    # make executable
    novnc.chmod(novnc.stat().st_mode | 0o111)
    return run_cmd(cmd, cwd=REPO_ROOT, stream=True, dry=args.dry)


def cmd_clean(args):
    clean = SCRIPTS_DIR / 'clean-build.sh'
    if not clean.exists():
        print('clean-build.sh not found.', file=sys.stderr)
        return 1
    cmd = [str(clean)]
    if args.yes:
        cmd += ['--yes']
    if args.remove_instance:
        cmd += ['--remove-instance']
    if args.instance_name:
        cmd += ['--instance-name', args.instance_name]
    clean.chmod(clean.stat().st_mode | 0o111)
    return run_cmd(cmd, cwd=REPO_ROOT, stream=True, dry=args.dry)


def cmd_stop(args):
    stop = SCRIPTS_DIR / 'stop-novnc.sh'
    if not stop.exists():
        print('stop-novnc.sh not found.', file=sys.stderr)
        return 1
    stop.chmod(stop.stat().st_mode | 0o111)
    return run_cmd([str(stop)], cwd=REPO_ROOT, stream=True, dry=args.dry)


def cmd_check(args):
    ok1 = check_scripts_syntax()
    ok2 = preflight_checks()
    if ok1 and ok2:
        print('Preflight checks passed.')
        return 0
    return 1


def cmd_deps(args):
    """Run dependency checks and optionally install Python requirements."""
    missing_bins = [b for b in ('multipass','qemu-system-x86_64','python3') if which_bin(b) is None]
    if missing_bins:
        print('Missing binaries: ' + ', '.join(missing_bins))
        # Provide brief platform-specific hints
        if sys.platform.startswith('darwin'):
            print('On macOS you can install Multipass via Homebrew: brew install --cask multipass')
        elif sys.platform.startswith('linux'):
            print('On Linux, follow distro instructions; on Ubuntu: sudo snap install multipass --classic')
        elif os.name == 'nt':
            print('On Windows: download Multipass from https://multipass.run or use Chocolatey: choco install multipass')
    else:
        print('All required binaries present.')

    # If requested, attempt to auto-install missing system binaries
    if getattr(args, 'install_binaries', False):
        print('Attempting to install missing system binaries...')
        rc_sys = install_system_binaries(bins=missing_bins, elevate=getattr(args, 'elevate', False))
        if rc_sys != 0:
            print('System package installation reported issues (see logs).')
        # after attempting installation, recompute missing bins
        missing_bins = [b for b in ('multipass','qemu-system-x86_64','python3') if which_bin(b) is None]
        if not missing_bins:
            print('System binaries installed successfully.')

    missing_pkgs = check_python_requirements()
    if missing_pkgs:
        print('Missing Python packages: ' + ', '.join(missing_pkgs))
        if args.install_python:
            print('Installing Python requirements...')
            if getattr(args, 'elevate', False):
                rc = install_python_requirements_elevated()
            else:
                rc = install_python_requirements()
            if rc != 0:
                print('Installation returned non-zero exit code:', rc)
                return 3
            # re-check after install
            missing_after = check_python_requirements()
            if missing_after:
                print('After installation, still missing packages: ' + ', '.join(missing_after))
                return 3
            print('Python requirements installed and verified.')
            # If binaries were missing earlier, report that via exit code 1
            return (1 if missing_bins else 0)
        # don't auto-install unless requested
        return 2
    else:
        print('Python requirements satisfied.')
    # Return 1 if binaries missing, else success
    return (1 if missing_bins else 0)


def main(argv=None):
    # If invoked without args, start interactive TUI
    if argv is None:
        argv = sys.argv[1:]

    if len(argv) == 0:
        # Prefer the full-screen Textual TUI if available
        # locate the TUI script: prefer scripts/ but fall back to repo root
        tui_script = SCRIPTS_DIR / 'simetrio_tui.py'
        if not tui_script.exists():
            alt = REPO_ROOT / 'simetrio_tui.py'
            if alt.exists():
                tui_script = alt
        try:
            import textual  # type: ignore
            have_textual = True
        except Exception:
            have_textual = False

        if not have_textual and tui_script.exists():
            # Offer to install requirements and report clearly; then attempt to import
            if sys.stdin.isatty():
                ans = input('Textual not found. Install UI deps now? (requires pip) [y/N]: ').strip().lower()
                if ans == 'y':
                    # Find requirements file either in scripts/ or repo root
                    r1 = SCRIPTS_DIR / 'requirements-simetrio.txt'
                    r2 = REPO_ROOT / 'requirements-simetrio.txt'
                    reqs = r1 if r1.exists() else (r2 if r2.exists() else None)
                    if reqs:
                        print('Installing UI dependencies (this may require network access and privileges)...')
                        rc = run_cmd([sys.executable, '-m', 'pip', 'install', '-r', str(reqs)], cwd=REPO_ROOT, stream=True)
                        if rc != 0:
                            print('Failed to install UI dependencies (pip returned non-zero). Aborting TUI launch.')
                            return 1
                        # try import again; if import fails, warn but attempt to
                        # execv the TUI anyway — a fresh interpreter is more
                        # likely to pick up newly installed site-packages.
                        try:
                            import textual  # type: ignore
                            have_textual = True
                        except Exception as e:
                            print('Warning: Textual import failed after installation:', e)
                            have_textual = False
                        # If we're interactive, relaunch the TUI in-place so the
                        # user is immediately dropped into the Textual interface.
                        if sys.stdin.isatty():
                            try:
                                print('Launching TUI...')
                                os.execv(sys.executable, [sys.executable, str(tui_script)])
                            except Exception as e:
                                print('Failed to execv relaunched TUI:', e)
                                return 1
                    else:
                        print('Requirements file not found in scripts/ or repo root. Cannot install UI deps.')
                        return 1
                else:
                    print('Textual not installed; skipping TUI. Exiting.')
                    return 1
            else:
                print('Textual not available and non-interactive shell; cannot launch TUI. Exiting.')
                return 1

        if have_textual and tui_script.exists():
            # Prefer interactive launch: if the user is at a terminal, run the TUI
            # attached to the terminal so it displays; only capture to a log when
            # running non-interactively (CI or piping).
            logdir = REPO_ROOT / 'build' / 'logs'
            logdir.mkdir(parents=True, exist_ok=True)
            logpath = logdir / 'simetrio-tui.log'

            if sys.stdin.isatty():
                # Interactive terminal: run TUI attached so user can interact with it.
                try:
                    rc = subprocess.call([sys.executable, str(tui_script)])
                except KeyboardInterrupt:
                    rc = 130
            else:
                # Non-interactive: capture stdout/stderr to a log for debugging
                with open(logpath, 'wb') as lf:
                    p = subprocess.Popen([sys.executable, str(tui_script)], stdout=lf, stderr=subprocess.STDOUT)
                    try:
                        rc = p.wait()
                    except KeyboardInterrupt:
                        p.terminate()
                        rc = p.wait()

            if rc != 0:
                print(f"Simetrio TUI exited with {rc}. Captured log: {logpath}")
                # print last 200 lines to make copying easier
                try:
                    with open(logpath, 'r', errors='replace') as rf:
                        lines = rf.readlines()
                        tail = lines[-200:]
                        print('\n=== Last log lines ===')
                        print(''.join(tail))
                except Exception as e:
                    print('Failed to read log:', e)
                return rc

            # If TUI script not available or textual not installed we exit instead of falling back to the legacy interactive menu
            print('TUI not available; exiting.')
            return 1

    parser = argparse.ArgumentParser(prog='simetrio', description='Simetrio — AIO build & test CLI for this repo')
    parser.add_argument('--dry', dest='dry', action='store_true', help='Print commands but do not execute')

    sub = parser.add_subparsers(dest='cmd', required=True)

    p_build = sub.add_parser('build', help='Build image (wraps multipass-run.sh)')
    p_build.add_argument('--name', default='stralyx')
    p_build.add_argument('--mem', default='4G')
    p_build.add_argument('--cpus', type=int, default=2)
    p_build.add_argument('--disk', default='20G')
    p_build.add_argument('--with-kde', dest='with_kde', action='store_true')
    p_build.add_argument('--with-calamares', dest='with_calamares', action='store_true')

    p_novnc = sub.add_parser('novnc', help='Run noVNC against an image')
    p_novnc.add_argument('image', help='Path to .img')

    p_clean = sub.add_parser('clean', help='Clean build artifacts and optionally remove multipass instance')
    p_clean.add_argument('--yes', action='store_true', help='Confirm removal')
    p_clean.add_argument('--remove-instance', action='store_true')
    p_clean.add_argument('--instance-name', default='stralyx')

    sub.add_parser('stop', help='Stop running noVNC (qemu + websockify)')
    sub.add_parser('check', help='Run preflight checks (binaries + script syntax)')
    p_deps = sub.add_parser('deps', help='Check dependencies and optionally install Python requirements')
    p_deps.add_argument('--install-python', action='store_true', help='Install python requirements from requirements-simetrio.txt')
    p_deps.add_argument('--install-binaries', action='store_true', help='Attempt to install missing system binaries (multipass, qemu). May require sudo')
    p_deps.add_argument('--elevate', action='store_true', help='Attempt to run pip install with elevated privileges (uses sudo on POSIX)')

    args = parser.parse_args(argv)

    if args.cmd == 'build':
        return cmd_build(args)
    if args.cmd == 'novnc':
        return cmd_novnc(args)
    if args.cmd == 'clean':
        return cmd_clean(args)
    if args.cmd == 'stop':
        return cmd_stop(args)
    if args.cmd == 'check':
        return cmd_check(args)
    if args.cmd == 'deps':
        return cmd_deps(args)

    return 0


if __name__ == '__main__':
    rc = main()
    sys.exit(rc)
